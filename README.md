# 基于WebSocket的实时文件传输应用

### 技术要点

1. 如何基于web实现文件传输，且服务器端不保存文件
2. 如何实时传输文件，且显示传输进度
3. 如何对大文件传输进行优化
4. 如何保障传输（流量控制、异常检测）
5. 如何断点续传

### 功能实现

**下载链接：**
- 为了通用性，改回Window.open ，先打开新标签页再下载再关闭新标签页

**chrome预连接：**
- 刷新页面的时候，会先预连接预渲染，成功后才会把上一个进程清除
- 在本项目中则会表现为，先get请求页面，再断开ws连接
- 使用自动刷新

**文件传输前的交互逻辑：**
- 以前文件传输是向某个人发起邀请，如果同意就进入一个房间页面，然后在里面传输。
- 之前那么做的话，用户操作不够友好，如果对多人传输文件，需要打开很多页面。
- 所以就是改成，直接传输文件，用户只需要对文件进行接收或者拒绝。

**传输问题：**
- 实时生成数据，是用的生成器，也就是说生成器中必须要响应新数据。
- 首先想到就是用redis，前端以bytebuffer分段读取然后通过ws发送到后端，后端将其存入redis。
- 如果必须接收方接收到一个数据包就回ack，然后发送方再接着发送的话，因为redis的原因，一个数据段就不能太大，但是数据段不能太大的话，就会影响发送速度。

**文件传输2.0:**
- 不再以接收方ack包作为继续传输的依据，而是后端回ack包，也就是说只需要考虑发送方上传文件时的丢包。因为接收方的下载文件实际上一个http请求，对于数据传输有一定了保障。只需要后端按序返回数据流就行了。
- 把发送方和接收方理解成生产者和消费者，双方不需要关心对方的操作，只需要确保能正常在消费队列里进行存取操作。
- 可以节省掉一部分后端与接收端间的网络传输耗时。
- 发送方上传完毕的时候会显示100%，只有当接收方下载完毕传输一个应答包，然后双方的进度才显示为完成。

**下载response头部：**
- Content-disposition，内容描述
- Content-length，内容大小

**轮询：**
- 如果没有获取到新的数据包，则 *0.1s* 再去获取；
- *10s* 没有获取到新的数据包，则break。

**Redis:**
- 文件数据包 *10s* 过期
- 文件描述包 *10hour* 过期

**传输超时：**
- 接收方每次收到数据描述包，都先移除旧的计时器，在设置新的计时器。
- 计时器是 *10s* 后就不在接收，并显示传输超时。
- 发送方同理

**取消传输：**
- 给文件描述包加上传输状态的字段
- 后端解包时，先判断是否正常传输，是则将数据包存入redis，否则回一个传输中断。
- 不管是发送方还是接收方，都向后端发送一个中断包，后端将文件描述包里的状态置为中断。

**断点续传：**
- 发送一个暂停或者继续包，后端响应的改变文件描述包里的状态
- 只有状态为正在传输时，count才计数，因此就不会5s后中断传输
- 暂停状态下，依旧每 *0.1s* 尝试获取新数据包

**流量控制：**
- 最小size: 100K；最大size: 5M
- 发送方每发送一个包设置一个定时器
- 每隔 *1s* 没有收到ack，则(size-100K)；
- 若 *1s* 内收到，则(size*2)
- 若 *2s* 内收到，则(size+100K)

**接入open_id:**

内部请求https当满足以下条件时会发生此问题：
1. Python版本为3.7+
2. 使用eventlet
3. 涉及ssl的地方使用https连接

原因是:
- ssl模块中的Python 3.6-> 3.7进行了一些重大更改。
- ssl.wrap_socket函数原型从python3.7.3更改了，_context不再是参数
- eventlet调用猴子补丁进行修补，会把socket替换，但是不会更改ssl的函数原型。
- 因此当eventlet执行补丁时，抛出错误 wrap_socket() got an unexpected keyword argument '_context'

issue：https://github.com/eventlet/eventlet/issues/526   
fix：https://github.com/eventlet/eventlet/pull/531

### 自定义协议

#### WS推送消息
```
{
    /* -1:错误; 100:正在传输; 101:暂停传输; 200:成功 */
    code: -1 || 100 || 101 || 200,
    data: {},
    msg: '提示信息',
}
```

#### 文件数据包（二进制）

**流程：**
- 从页面input可以获取到文件对象File。
- 使用FileReader读取File内容，获取到对应的ArrayBuffer对象。
- 为了接收数据方便，我们需要给发送的数据增加一个头部信息，用于标识每一次请求，以便后台可以根据头部信息来区分每次请求，并根据这个信息发送响应信息，前端可以在onmessge中解析这个头部信息来跟请求对应上。
- ArrayBuffer是一个不可读写的内存对象，如果要加头，需要用到DataView视图对象。
- 关键是要把多个视图对象拼接成一个视图对象，获取到新的ArrayBuffer对象。

**前端打包:**
- 文件id、开始的字节、截取段的字节长度。
- 整数可能会溢出，但是字符的ASCII是可以明确范围的（0-127），所以先把整数转为字符串，如何对字符串进行一个编码的协议设计。
- Unit8Array（无符号8 位整数数组视图，0-255），长度=要编码的字符串的长度+1。
- 第一个放字符串长度，随后依次放入字符串中对应字符的ASCII编码（charCodeAt）
- 方便以后的优化，可以更改截取长度，而后端不需要做改动

**后端解包:**
- 使用python的struct模块，以’b‘的格式unpack
- 8位也就是1字节，chr转字符
- 把字符数组转为字符串

### 依赖包版本

> requirements.txt

### 环境搭建（具体看Dockerfile）

> Docker + Alpine + Flask + Gunicorn

### 构建项目
> ./rebuild.sh